#include <iostream>
#include <vector>
#include <string>
#include <rapidxml.hpp>
#include <rapidxml_utils.hpp>
#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include "constants.h"
#include "lodepng.h"
#include "shaderprogram.h"
#include "myCube.h"
#include <glm/gtc/type_ptr.hpp>
#include "myPyramid.h"



using namespace rapidxml;




float speed_x = 0;
float speed_y = 0;
float aspectRatio = 1;

float camfr = 0;
float camlr = 0;
float s = 0;
int animate = 0;

ShaderProgram* sp;


struct Transition {
    float x, y;
    std::string type;
    std::string ID;
};


struct Edge {
    float startX, startY;
    float endX, endY;
    int source, target;
    std::string multiplicity;
};


struct Place {
    float x, y;
    std::string marking;
    std::string ID;
};

//Odkomentuj, ¿eby rysowaæ kostkê
float* cVertices = myCubeVertices;
float* cNormals = myCubeNormals;
float* cTexCoords = myCubeTexCoords;
float* cColors = myCubeColors;
int cVertexCount = myCubeVertexCount;



float* pVertices = myPyramidVertices;
float* pNormals = myPyramidNormals;
float* pTexCoords = myPyramidTexCoords;
float* pColors = myPyramidColors;
int pVertexCount = myPyramidVertexCount;





//Procedura obs³ugi b³êdów
void error_callback(int error, const char* description) {
    fputs(description, stderr);
}

void drawCube(float x, float y) {
    glm::mat4 M = glm::mat4(1.0f);
    M = glm::translate(M, glm::vec3(x, y, 0.0f)); // Wylicz macierz translacji dla szeœcianu

    glUniformMatrix4fv(sp->u("M"), 1, false, glm::value_ptr(M));

    glEnableVertexAttribArray(sp->a("vertex"));  // W³¹cz przesy³anie danych do atrybutu vertex
    glVertexAttribPointer(sp->a("vertex"), 4, GL_FLOAT, false, 0, cVertices); // Wska¿ tablicê z danymi dla atrybutu vertex

    // Ustaw kolor na ró¿owy
    glUniform4f(sp->u("color"), 1, 0, 1, 1);

    glDrawArrays(GL_TRIANGLES, 0, cVertexCount); // Narysuj szeœcian

    glDisableVertexAttribArray(sp->a("vertex"));  // Wy³¹cz przesy³anie danych do atrybutu vertex
}

void moveCubeAlongEdge(const Edge& edge) {
    float startX = edge.startX / 20.0f;
    float startY = edge.startY / 20.0f;
    float endX = edge.endX / 20.0f;
    float endY = edge.endY / 20.0f;

    glm::vec2 startPos = glm::vec2(startX, startY);
    glm::vec2 endPos = glm::vec2(endX, endY);

    // Obliczanie kierunku ruchu
    glm::vec2 direction = glm::normalize(endPos - startPos);
    float distance = glm::distance(startPos, endPos);

    // Obliczanie prêdkoœci ruchu (tu mo¿esz dostosowaæ prêdkoœæ)
    float speed = 0.1f;

    // Obliczanie nowej pozycji
    glm::vec2 newPosition = startPos + direction * speed;

    // Aktualizacja pozycji szeœcianu
    float cubeX = newPosition.x * 20.0f;
    float cubeY = newPosition.y * 20.0f;

    // Rysowanie szeœcianu na nowej pozycji
    drawCube(cubeX, cubeY); // Tutaj nale¿y napisaæ funkcjê rysuj¹c¹ szeœcian na danej pozycji
}

void decreaseMultiplicity(std::vector<Place>& places, int targetID) {
    for (auto& place : places) {
        if (std::stoi(place.ID) == targetID) {
            int newMultiplicity = std::stoi(place.marking) - 1;
            place.marking = std::to_string(newMultiplicity);
            break;
        }
    }
}



void keyCallback(GLFWwindow* window, int key, int scancode, int action, int mods) {
    if (action == GLFW_PRESS) {
        if (key == GLFW_KEY_LEFT) speed_x = -PI / 2;
        if (key == GLFW_KEY_RIGHT) speed_x = PI / 2;
        if (key == GLFW_KEY_UP) speed_y = PI / 2;
        if (key == GLFW_KEY_DOWN) speed_y = -PI / 2;
    }
    if (action == GLFW_RELEASE) {
        if (key == GLFW_KEY_LEFT) speed_x = 0;
        if (key == GLFW_KEY_RIGHT) speed_x = 0;
        if (key == GLFW_KEY_UP) speed_y = 0;
        if (key == GLFW_KEY_DOWN) speed_y = 0;
    }

    if (action == GLFW_REPEAT || action == GLFW_PRESS) {
        if (key == GLFW_KEY_A) {
            camlr += 0.5f; // Increase camlr when 'A' key is held down
        }
        if (key == GLFW_KEY_D) {
            camlr -= 0.5f; // Decrease camlr when 'D' key is held down
        }
        if (key == GLFW_KEY_W) {
            camfr += 0.5f; // Increase camfr when 'W' key is held down
        }
        if (key == GLFW_KEY_S) {
            camfr -= 0.5f; // Decrease camfr when 'S' key is held down
        }
    }

    if (action == GLFW_PRESS) {
        if (key == GLFW_KEY_0) animate = 0;
        if (key == GLFW_KEY_1) animate = 1;
    }
}


void scroll_callback(GLFWwindow* window, double xoffset, double yoffset) {

    if (yoffset > 0) {
        s += 0.5;
    }
    if (yoffset < 0) {
        s -= 0.5;
    }

}


void windowResizeCallback(GLFWwindow* window, int width, int height) {
    if (height == 0) return;
    aspectRatio = (float)width / (float)height;
    glViewport(0, 0, width, height);
}

//Procedura inicjuj¹ca
void initOpenGLProgram(GLFWwindow* window) {
    //************Tutaj umieszczaj kod, który nale¿y wykonaæ raz, na pocz¹tku programu************
    glClearColor(0, 0, 0, 1);
    glEnable(GL_DEPTH_TEST);
    glfwSetWindowSizeCallback(window, windowResizeCallback);
    glfwSetKeyCallback(window, keyCallback);
    glfwSetScrollCallback(window, scroll_callback);

    sp = new ShaderProgram("v_simplest.glsl", NULL, "f_simplest.glsl");
}




//Zwolnienie zasobów zajêtych przez program
void freeOpenGLProgram(GLFWwindow* window) {
    //************Tutaj umieszczaj kod, który nale¿y wykonaæ po zakoñczeniu pêtli g³ównej************

    delete sp;
}


void drawPyramid() {
    glm::mat4 M = glm::mat4(1.0f);
    M = glm::translate(M, glm::vec3(0.0f, 0.0f, 0.0f)); // Wylicz macierz modelu dla piramidy

    glUniformMatrix4fv(sp->u("M"), 1, false, glm::value_ptr(M));

    glEnableVertexAttribArray(sp->a("vertex"));  // W³¹cz przesy³anie danych do atrybutu vertex
    glVertexAttribPointer(sp->a("vertex"), 4, GL_FLOAT, false, 0, pVertices); // Wska¿ tablicê z danymi dla atrybutu vertex

    // U¿yj kolorów z pliku myPyramidColors
    glEnableVertexAttribArray(sp->a("color"));
    glVertexAttribPointer(sp->a("color"), 4, GL_FLOAT, false, 0, pColors);

    glDrawArrays(GL_TRIANGLES, 0, pVertexCount); // Narysuj piramidê

    glDisableVertexAttribArray(sp->a("vertex"));  // Wy³¹cz przesy³anie danych do atrybutu vertex
    glDisableVertexAttribArray(sp->a("color"));
}

void drawPyramidOnEdge(const Edge& edge, const glm::vec2& startPos, const glm::vec2& endPos) {
    glm::vec2 middlePoint = ((startPos + endPos) / 2.0f);
    glm::vec2 direction = glm::normalize(endPos - startPos);
    float angle = atan2(direction.y, direction.x);

    glm::mat4 M = glm::mat4(1.0f);
    M = glm::translate(M, glm::vec3(middlePoint, 0.0f)); // Przenieœ do œrodkowego punktu krawêdzi
    M = glm::rotate(M, angle-PI/2, glm::vec3(0, 0, 1)); // Obrót tak, aby czubek piramidy wskazywa³ cel
    M = glm::scale(M, glm::vec3(0.5, 0.5, 1));
    glUniformMatrix4fv(sp->u("M"), 1, false, glm::value_ptr(M));

    glEnableVertexAttribArray(sp->a("vertex"));  // W³¹cz przesy³anie danych do atrybutu vertex
    glVertexAttribPointer(sp->a("vertex"), 4, GL_FLOAT, false, 0, pVertices); // Wska¿ tablicê z danymi dla atrybutu vertex

    // Ustaw kolor na niebieski
    glUniform4f(sp->u("color"), 0, 0, 1, 1);

    glDrawArrays(GL_TRIANGLES, 0, pVertexCount); // Narysuj piramidê

    glDisableVertexAttribArray(sp->a("vertex"));  // Wy³¹cz przesy³anie danych do atrybutu vertex
}



void drawPlaces(const std::vector<Place>& places) {
    for (const auto& node : places) {
        glm::mat4 M = glm::mat4(1.0f);
        M = glm::translate(M, glm::vec3(node.x / 20, node.y / 20, 0.0f)); //Wylicz macierz modelu

        glUniformMatrix4fv(sp->u("M"), 1, false, glm::value_ptr(M));

        glEnableVertexAttribArray(sp->a("vertex"));  //W³¹cz przesy³anie danych do atrybutu vertex
        glVertexAttribPointer(sp->a("vertex"), 4, GL_FLOAT, false, 0, cVertices); //Wska¿ tablicê z danymi dla atrybutu vertex



        //glEnableVertexAttribArray(sp->a("color"));
        //glVertexAttribPointer(sp->a("color"), 4, GL_FLOAT, false, 0, myCubeColors);

        glUniform4f(sp->u("color"), 1, 0, 0, 1);

        glDrawArrays(GL_TRIANGLES, 0, cVertexCount); //Narysuj obiekt

        glDisableVertexAttribArray(sp->a("vertex"));  //Wy³¹cz przesy³anie danych do atrybutu vertex
        glDisableVertexAttribArray(sp->a("color"));
    }

}

void drawTransitions(const std::vector<Transition>& transitions) {
    for (const auto& node : transitions) {
        glm::mat4 M = glm::mat4(1.0f);
        M = glm::translate(M, glm::vec3(node.x / 20, node.y / 20, 0.0f)); //Wylicz macierz modelu

        glUniformMatrix4fv(sp->u("M"), 1, false, glm::value_ptr(M));

        glEnableVertexAttribArray(sp->a("vertex"));  //W³¹cz przesy³anie danych do atrybutu vertex
        glVertexAttribPointer(sp->a("vertex"), 4, GL_FLOAT, false, 0, cVertices); //Wska¿ tablicê z danymi dla atrybutu vertex

        glUniform4f(sp->u("color"), 1, 1, 0, 1);


        //glEnableVertexAttribArray(sp->a("color"));
        //glVertexAttribPointer(sp->a("color"), 4, GL_FLOAT, false, 0, myCubeColors);


        glDrawArrays(GL_TRIANGLES, 0, cVertexCount); //Narysuj obiekt

        glDisableVertexAttribArray(sp->a("vertex"));  //Wy³¹cz przesy³anie danych do atrybutu vertex
        glDisableVertexAttribArray(sp->a("color"));
    }
}


void drawEdges(const std::vector<Edge>& edges, const std::vector<Place>& places, const std::vector<Transition>& transitions) {
    for (const auto& edge : edges) {
        float startX, startY, endX, endY;

        
        for (const auto& place : places) {
            if (place.ID == std::to_string(edge.source)) {
                startX = place.x / 20.0f;
                startY = place.y / 20.0f;
                break;
            }
        }

        for (const auto& transition : transitions) {
            if (transition.ID == std::to_string(edge.source)) {
                startX = transition.x / 20.0f;
                startY = transition.y / 20.0f;
                break;
            }
        }


        
        for (const auto& place : places) {
            if (place.ID == std::to_string(edge.target)) {
                endX = place.x / 20.0f;
                endY = place.y / 20.0f;
                break;
            }
        }

        for (const auto& transition : transitions) {
            if (transition.ID == std::to_string(edge.target)) {
                endX = transition.x / 20.0f;
                endY = transition.y / 20.0f;
                break;
            }
        }

        glm::vec2 startPos = glm::vec2(startX, startY);
        glm::vec2 endPos = glm::vec2(endX,endY);

        drawPyramidOnEdge(edge, startPos, endPos);

        // Obliczanie d³ugoœci i kierunku prostopad³oœcianu
        float length = glm::distance(glm::vec2(startX, startY) / 2.0f, glm::vec2(endX, endY) / 2.0f);
        glm::vec2 direction = glm::normalize(glm::vec2(endX - startX, endY - startY));

        // Ustawienie skali prostopad³oœcianu (d³ugoœæ, szerokoœæ, wysokoœæ)
        glm::vec3 scale = glm::vec3(length, 0.1f, 0.1f);

        // Obliczanie œrodka prostopad³oœcianu
        glm::vec3 center = glm::vec3((startX + endX) / 2.0f, (startY + endY) / 2.0f, 0.0f);

        // Obliczanie k¹ta obrotu prostopad³oœcianu (na p³aszczyŸnie XY)
        float angle = atan2(direction.y, direction.x);

        // Rysowanie prostopad³oœcianu
        glm::mat4 M = glm::mat4(1.0f);
        M = glm::translate(M, center); // Wylicz macierz translacji
        M = glm::rotate(M, angle, glm::vec3(0, 0, 1)); // Wylicz macierz rotacji
        M = glm::scale(M, scale); // Wylicz macierz skalowania

        glUniformMatrix4fv(sp->u("M"), 1, false, glm::value_ptr(M));

        glEnableVertexAttribArray(sp->a("vertex"));  // W³¹cz przesy³anie danych do atrybutu vertex
        glVertexAttribPointer(sp->a("vertex"), 4, GL_FLOAT, false, 0, cVertices); // Wska¿ tablicê z danymi dla atrybutu vertex

        //glEnableVertexAttribArray(sp->a("color"));
        //glVertexAttribPointer(sp->a("color"), 4, GL_FLOAT, false, 0, myCubeColors);

        glUniform4f(sp->u("color"), 0, 0, 1, 1);

        glDrawArrays(GL_TRIANGLES, 0, cVertexCount); // Narysuj obiekt

        glDisableVertexAttribArray(sp->a("vertex"));  // Wy³¹cz przesy³anie danych do atrybutu vertex
    }
}


void drawScene(GLFWwindow* window, float angle_x, float angle_y, const std::vector<Place>& places, const std::vector<Transition>& transitions, const std::vector<Edge>& edges) {
    //************Tutaj umieszczaj kod rysuj¹cy obraz******************l
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glm::mat4 V = glm::lookAt(glm::vec3(camlr + 0.0f, 0.0f, camfr + (-5.0f)),
        glm::vec3(camlr - 0.0f, 0.0f, camfr - 0.0f),
        glm::vec3(0.0f, 1.0f, 0.0f));

    glm::mat4 P = glm::perspective(50.0f * PI / 180.0f, aspectRatio, 0.01f, 50.0f); //Wylicz macierz rzutowania

    sp->use(); //Aktywacja programu cieniuj¹cego
    //Przeslij parametry programu cieniuj¹cego do karty graficznej
    glUniformMatrix4fv(sp->u("P"), 1, false, glm::value_ptr(P));
    glUniformMatrix4fv(sp->u("V"), 1, false, glm::value_ptr(V));







    drawPlaces(places);
    drawTransitions(transitions);
    drawEdges(edges, places, transitions);
    drawPyramid();


    glfwSwapBuffers(window); //Przerzuæ tylny bufor na przedni
}

int main(void) {

    std::vector<Place> places;
    std::vector<Transition> transitions;
    std::vector<Edge> edges;



    xml_document<> doc;
    file<> xmlFile("test.pn");
    doc.parse<0>(xmlFile.data());

    xml_node<>* root = doc.first_node();

    // place
    xml_node<>* placeClassNode = root->first_node("nodeclasses")->first_node("nodeclass");
    for (xml_node<>* placeNode = placeClassNode->first_node("node");
        placeNode;
        placeNode = placeNode->next_sibling("node")) {

        float x = std::stof(placeNode->first_node("graphics")->first_node("graphic")->first_attribute("x")->value());
        float y = std::stof(placeNode->first_node("graphics")->first_node("graphic")->first_attribute("y")->value());
        std::string ID = placeNode->first_attribute("id")->value();
        //places.push_back({ x, y, "Place", ID });

        xml_node<>* markingNode = nullptr;
        for (xml_node<>* attributeNode = placeNode->first_node("attribute"); attributeNode; attributeNode = attributeNode->next_sibling("attribute")) {
            if (std::string(attributeNode->first_attribute("name")->value()) == "Marking") {
                markingNode = attributeNode;
                break;
            }
        }


        if (markingNode) {

            std::string marking = markingNode->first_node()->value();
            places.push_back({ x, y, marking, ID });
        }
    }

    // transition
    xml_node<>* transitionClassNode = placeClassNode->next_sibling("nodeclass");
    for (xml_node<>* transitionNode = transitionClassNode->first_node("node");
        transitionNode;
        transitionNode = transitionNode->next_sibling("node")) {
        float x = std::stof(transitionNode->first_node("graphics")->first_node("graphic")->first_attribute("x")->value());
        float y = std::stof(transitionNode->first_node("graphics")->first_node("graphic")->first_attribute("y")->value());
        std::string ID = transitionNode->first_attribute("id")->value();
        transitions.push_back({ x, y, "Transition", ID });
    }

    // krawêdŸ
    xml_node<>* edgeClassNode = root->first_node("edgeclasses")->first_node("edgeclass");
    for (xml_node<>* edgeNode = edgeClassNode->first_node("edge");
        edgeNode;
        edgeNode = edgeNode->next_sibling("edge")) {
        float startX = std::stof(edgeNode->first_node("graphics")->first_node("graphic")->first_node("points")->first_node("point")->first_attribute("x")->value());
        float startY = std::stof(edgeNode->first_node("graphics")->first_node("graphic")->first_node("points")->first_node("point")->first_attribute("y")->value());
        float endX = std::stof(edgeNode->first_node("graphics")->first_node("graphic")->first_node("points")->last_node("point")->first_attribute("x")->value());
        float endY = std::stof(edgeNode->first_node("graphics")->first_node("graphic")->first_node("points")->last_node("point")->first_attribute("y")->value());
        int source = std::stof(edgeNode->first_attribute("source")->value());
        int target = std::stof(edgeNode->first_attribute("target")->value());


        xml_node<>* multiplicityNode = nullptr;
        for (xml_node<>* attributeNode = edgeNode->first_node("attribute"); attributeNode; attributeNode = attributeNode->next_sibling("attribute")) {
            if (std::string(attributeNode->first_attribute("name")->value()) == "Multiplicity") {
                multiplicityNode = attributeNode;
                break;
            }
        }


        if (multiplicityNode) {

            std::string multiplicity = multiplicityNode->first_node()->value();
            //markedPlaces.push_back({ x, y, marking, ID });
            edges.push_back({ startX, startY, endX, endY, source, target, multiplicity });
        }



    }


    GLFWwindow* window; //WskaŸnik na obiekt reprezentuj¹cy okno

    glfwSetErrorCallback(error_callback); //Zarejestruj procedurê obs³ugi b³êdów

    if (!glfwInit()) { //Zainicjuj bibliotekê GLFW
        fprintf(stderr, "Nie mo¿na zainicjowaæ GLFW.\n");
        exit(EXIT_FAILURE);
    }

    window = glfwCreateWindow(800, 600, "OpenGL", NULL, NULL);  //Utwórz okno 800x600 o tytule "OpenGL" i kontekst OpenGL.

    if (!window) //Je¿eli okna nie uda³o siê utworzyæ, to zamknij program
    {
        fprintf(stderr, "Nie mo¿na utworzyæ okna.\n");
        glfwTerminate();
        exit(EXIT_FAILURE);
    }

    glfwMakeContextCurrent(window); //Od tego momentu kontekst okna staje siê aktywny i polecenia OpenGL bêd¹ dotyczyæ w³aœnie jego.
    glfwSwapInterval(1); //Czekaj na 1 powrót plamki przed pokazaniem ukrytego bufora

    if (glewInit() != GLEW_OK) { //Zainicjuj bibliotekê GLEW
        fprintf(stderr, "Nie mo¿na zainicjowaæ GLEW.\n");
        exit(EXIT_FAILURE);
    }

    initOpenGLProgram(window); //Operacje inicjuj¹ce

    //G³ówna pêtla
    float angle_x = 0; //Aktualny k¹t obrotu obiektu
    float angle_y = 0; //Aktualny k¹t obrotu obiektu
    glfwSetTime(0); //Zeruj timer



    while (!glfwWindowShouldClose(window)) //Tak d³ugo jak okno nie powinno zostaæ zamkniête
    {
        angle_x += speed_x * glfwGetTime(); //Zwiêksz/zmniejsz k¹t obrotu na podstawie prêdkoœci i czasu jaki up³yna³ od poprzedniej klatki
        angle_y += speed_y * glfwGetTime(); //Zwiêksz/zmniejsz k¹t obrotu na podstawie prêdkoœci i czasu jaki up³yna³ od poprzedniej klatki
        glfwSetTime(0); //Zeruj timer
        drawScene(window, angle_x, angle_y, places, transitions, edges); //Wykonaj procedurê rysuj¹c¹
        /*
        if (animate) {
            moveCubeAlongEdge(edges[0]);
            decreaseMultiplicity(places, edges[0].source);
        }
        */
        glfwPollEvents(); //Wykonaj procedury callback w zale¿noœci od zdarzeñ jakie zasz³y.
    }

    freeOpenGLProgram(window);

    glfwDestroyWindow(window); //Usuñ kontekst OpenGL i okno
    glfwTerminate(); //Zwolnij zasoby zajête przez GLFW
    exit(EXIT_SUCCESS);
}







