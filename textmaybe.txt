#include <iostream>
#include <vector>
#include <string>
#include <rapidxml.hpp>
#include <rapidxml_utils.hpp>
#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include "constants.h"
#include "lodepng.h"
#include "shaderprogram.h"
#include "myCube.h"
#include <glm/gtc/type_ptr.hpp>
#include "myPyramid.h"

#define GLT_IMPLEMENTATION
#include "gltext.h" // Dodane dla wyœwietlania tekstu

using namespace rapidxml;

float speed_x = 0;
float speed_y = 0;
float aspectRatio = 1;
float camfr = 0;
float camlr = 0;
float s = 0;
int animate = 0;
float biggify = 1;
float expand = 1;

ShaderProgram* sp;

struct Transition {
    float x, y;
    std::string type;
    std::string ID;
};

struct Edge {
    float startX, startY;
    float endX, endY;
    int source, target;
    std::string multiplicity;
};

struct Place {
    float x, y;
    std::string marking;
    std::string ID;
};

float* cVertices = myCubeVertices;
float* cNormals = myCubeNormals;
float* cTexCoords = myCubeTexCoords;
float* cColors = myCubeColors;
int cVertexCount = myCubeVertexCount;

float* pVertices = myPyramidVertices;
float* pNormals = myPyramidNormals;
float* pTexCoords = myPyramidTexCoords;
float* pColors = myPyramidColors;
int pVertexCount = myPyramidVertexCount;

void error_callback(int error, const char* description) {
    fputs(description, stderr);
}

void drawCube(float x, float y) {
    glm::mat4 M = glm::mat4(1.0f);
    M = glm::translate(M, glm::vec3(x, y, 0.0f));
    M = glm::scale(M, glm::vec3(0.5, 0.5, 0.5) * biggify);
    glUniformMatrix4fv(sp->u("M"), 1, false, glm::value_ptr(M));
    glEnableVertexAttribArray(sp->a("vertex"));
    glVertexAttribPointer(sp->a("vertex"), 4, GL_FLOAT, false, 0, cVertices);
    glUniform4f(sp->u("color"), 1, 0, 1, 1);
    glDrawArrays(GL_TRIANGLES, 0, cVertexCount);
}

void drawText(GLTtext* text, const char* str, float x, float y, float scale) {
    gltSetText(text, str);
    gltBeginDraw();
    gltDrawText2D(text, x, y, scale);
    gltEndDraw();
}

void drawPlaces(const std::vector<Place>& places, GLTtext* text) {
    for (const auto& place : places) {
        glm::mat4 M = glm::mat4(1.0f);
        M = glm::translate(M, glm::vec3((place.x / 20.0f) * expand , (place.y / 20.0f) * expand , 0.0f));
        M = glm::scale(M, glm::vec3(1, 1, 1) * biggify);
        glUniformMatrix4fv(sp->u("M"), 1, false, glm::value_ptr(M));
        glEnableVertexAttribArray(sp->a("vertex"));
        glVertexAttribPointer(sp->a("vertex"), 4, GL_FLOAT, false, 0, cVertices);
        glUniform4f(sp->u("color"), 1, 0, 0, 1);
        glDrawArrays(GL_TRIANGLES, 0, cVertexCount);
        glDisableVertexAttribArray(sp->a("vertex"));
        char buffer[32];
        sprintf(buffer, "ID: %s", place.ID.c_str());
        drawText(text, buffer, place.x / 20.0f * expand, place.y / 20.0f * expand - 20.0f, 0.5f);
    }
}

void drawTransitions(const std::vector<Transition>& transitions, GLTtext* text) {
    for (const auto& transition : transitions) {
        glm::mat4 M = glm::mat4(1.0f);
        M = glm::translate(M, glm::vec3((transition.x / 20.0f) *expand, (transition.y / 20.0f) * expand, 0.0f));
        M = glm::scale(M, glm::vec3(1, 1, 1) * biggify);
        glUniformMatrix4fv(sp->u("M"), 1, false, glm::value_ptr(M));
        glEnableVertexAttribArray(sp->a("vertex"));
        glVertexAttribPointer(sp->a("vertex"), 4, GL_FLOAT, false, 0, cVertices);
        glUniform4f(sp->u("color"), 1, 1, 0, 1);
        glDrawArrays(GL_TRIANGLES, 0, cVertexCount);
        glDisableVertexAttribArray(sp->a("vertex"));
        char buffer[32];
        sprintf(buffer, "ID: %s", transition.ID.c_str());
        drawText(text, buffer, transition.x / 20.0f * expand, transition.y / 20.0f * expand - 20.0f, 0.5f);
    }
}

void initOpenGLProgram(GLFWwindow* window) {
    glClearColor(0, 0, 0, 1);
    glEnable(GL_DEPTH_TEST);
    glfwSetWindowSizeCallback(window, windowResizeCallback);
    glfwSetKeyCallback(window, keyCallback);
    glfwSetScrollCallback(window, scroll_callback);
    sp = new ShaderProgram("v_simplest.glsl", NULL, "f_simplest.glsl");
    if (!gltInit()) {
        fprintf(stderr, "Failed to initialize glText\n");
        exit(EXIT_FAILURE);
    }
}

void freeOpenGLProgram(GLFWwindow* window) {
    gltTerminate();
    delete sp;
}

void drawScene(GLFWwindow* window, float angle_x, float angle_y, const std::vector<Place>& places, const std::vector<Transition>& transitions, const std::vector<Edge>& edges, GLTtext* text) {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glm::mat4 V = glm::lookAt(glm::vec3(camlr + 0.0f, 0.0f, camfr + (-5.0f)),
        glm::vec3(camlr - 0.0f, 0.0f, camfr - 0.0f),
        glm::vec3(0.0f, 1.0f, 0.0f));
    glm::mat4 P = glm::perspective(50.0f * PI / 180.0f, aspectRatio, 0.01f, 1000.0f);
    sp->use();
    glUniformMatrix4fv(sp->u("P"), 1, false, glm::value_ptr(P));
    glUniformMatrix4fv(sp->u("V"), 1, false, glm::value_ptr(V));
    drawPlaces(places, text);
    drawTransitions(transitions, text);
    drawEdges(edges, places, transitions);
    if (animate) {
        for (const auto& edge : edges) {
            moveCubeAlongEdge(edge);
            decreaseMarking(places, edge.source);
        }
    }
    glfwSwapBuffers(window);
}

int main(void) {
    std::vector<Place> places;
    std::vector<Transition> transitions;
    std::vector<Edge> edges;

    xml_document<> doc;
    file<> xmlFile("test.pn");
    doc.parse<0>(xmlFile.data());
    xml_node<>* root = doc.first_node();
    xml_node<>* placeClassNode = root->first_node("nodeclasses")->first_node("nodeclass");
    for (xml_node<>* placeNode = placeClassNode->first_node("node");
        placeNode;
        placeNode = placeNode->next_sibling("node")) {
        float x = std::stof(placeNode->first_node("graphics")->first_node("graphic")->first_attribute("x")->value());
        float y = std::stof(placeNode->first_node("graphics")->first_node("graphic")->first_attribute("y")->value());
        std::string id = placeNode->first_attribute("id")->value();
        places.push_back({ x, y, "0", id });
    }
    xml_node<>* transitionClassNode = root->first_node("nodeclasses")->first_node("nodeclass")->next_sibling("nodeclass");
    for (xml_node<>* transitionNode = transitionClassNode->first_node("node");
        transitionNode;
        transitionNode = transitionNode->next_sibling("node")) {
        float x = std::stof(transitionNode->first_node("graphics")->first_node("graphic")->first_attribute("x")->value());
        float y = std::stof(transitionNode->first_node("graphics")->first_node("graphic")->first_attribute("y")->value());
        std::string id = transitionNode->first_attribute("id")->value();
        transitions.push_back({ x, y, "", id });
    }
    for (xml_node<>* arcNode = root->first_node("net")->first_node("arc");
        arcNode;
        arcNode = arcNode->next_sibling("arc")) {
        std::string source = arcNode->first_attribute("source")->value();
        std::string target = arcNode->first_attribute("target")->value();
        int sourceIdx = -1, targetIdx = -1;
        for (int i = 0; i < places.size(); ++i) {
            if (places[i].ID == source) {
                sourceIdx = i;
                break;
            }
        }
        for (int i = 0; i < transitions.size(); ++i) {
            if (transitions[i].ID == target) {
                targetIdx = i;
                break;
            }
        }
        if (sourceIdx == -1) {
            for (int i = 0; i < transitions.size(); ++i) {
                if (transitions[i].ID == source) {
                    sourceIdx = i;
                    break;
                }
            }
        }
        if (targetIdx == -1) {
            for (int i = 0; i < places.size(); ++i) {
                if (places[i].ID == target) {
                    targetIdx = i;
                    break;
                }
            }
        }
        if (sourceIdx != -1 && targetIdx != -1) {
            edges.push_back({ places[sourceIdx].x, places[sourceIdx].y, transitions[targetIdx].x, transitions[targetIdx].y, sourceIdx, targetIdx, "" });
        }
    }
    if (!glfwInit()) {
        fprintf(stderr, "Nie mo¿na zainicjowaæ GLFW.\n");
        exit(EXIT_FAILURE);
    }
    GLFWwindow* window = glfwCreateWindow(500, 500, "Siatka Petriego", NULL, NULL);
    if (!window) {
        glfwTerminate();
        exit(EXIT_FAILURE);
    }
    glfwMakeContextCurrent(window);
    glfwSwapInterval(1);
    if (glewInit() != GLEW_OK) {
        fprintf(stderr, "Nie mo¿na zainicjowaæ GLEW.\n");
        exit(EXIT_FAILURE);
    }
    initOpenGLProgram(window);
    glfwSetTime(0);
    GLTtext* text = gltCreateText();
    while (!glfwWindowShouldClose(window)) {
        drawScene(window, speed_x * glfwGetTime(), speed_y * glfwGetTime(), places, transitions, edges, text);
        glfwPollEvents();
    }
    freeOpenGLProgram(window);
    gltDeleteText(text);
    glfwDestroyWindow(window);
    glfwTerminate();
    return 0;
}
