void moveCubeAlongEdge(const std::vector<Edge>& edges, const std::vector<Place>& places) {
    // Find all valid edges where source places have enough tokens
    if (typeofedge == 0) {
        std::vector<int> validEdgeIndices = validEdge(edges, places);
        std::cout << "Begining: " << std::endl;
        // If there are no valid edges, stop the animation
        if (validEdgeIndices.empty()) {
            animationState.isAnimating = false;
            return;
        }

        // Choose a random valid edge
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> distr(0, validEdgeIndices.size() - 1);
        int randomIndex = distr(gen);
        int chosenEdgeIndex = validEdgeIndices[randomIndex];
        animationState.currentEdgeIndex = chosenEdgeIndex;
        std::cout << "Random" << std::endl;
        const float animationSpeed = 0.01f; // Speed of animation
        const Edge& currentEdge = edges[animationState.currentEdgeIndex];
        std::cout << "og Wartoœæ sourceID: " << currentEdge.source << std::endl;
        if (!animationState.isAnimating) return;



        if (animationState.progress == 0.0f) {
            animationState.startPos = glm::vec2(currentEdge.startX / 20.0f * expand, currentEdge.startY / 20.0f * expand);
            animationState.endPos = glm::vec2(currentEdge.endX / 20.0f * expand, currentEdge.endY / 20.0f * expand);
        }

        // Interpolate position between start and end
        glm::vec2 interpolatedPosition = animationState.startPos + animationState.progress * (animationState.endPos - animationState.startPos);

        // Update cube position
        float cubeX = interpolatedPosition.x;
        float cubeY = interpolatedPosition.y;

        // Draw cube at the new position
        drawCube(cubeX, cubeY); // Assuming there's a function to draw cube at a given position

        // Update animation progress
        animationState.progress += animationSpeed;
        if (animationState.progress >= 1.0f) {
            animationState.progress = 0.0f;
            
            // Kiedy skoñczy³a siê animacja z miejsca do tranzycji chcemy zacz¹æ kilka animacji na raz z ranzycji do miejsca czyli animacjê wszystkich mo¿liwych krawêdzi znalezionych w funkcji findrandomedgewithsource    
            int sourceID = edges[animationState.currentEdgeIndex].source;

            //int targetID = edgeData.first;
            std::cout << "Wartoœæ sourceID: " << sourceID << std::endl;
            //std::cout << "Wartoœæ targetID: " << targetID << std::endl;
            //std::cout << "Wartoœæ multipliity: " << edgeData.second << std::endl;
            decreaseMarking(places, sourceID);

            //increaseMarking(places, targetID, std::stoi(edgeData.second));

            std::cout << "begining valid edge: " << std::endl;
            // After completing the movement, check if there are still valid edges to continue animation
            validEdgeIndices = validEdge(edges, places);
            if (validEdgeIndices.empty()) {
                animationState.isAnimating = false;
            }
        }
        typeofedge = 1;
    }
    if (typeofedge == 1) {
        std::vector<std::pair<int, std::string>> edgeData = findAllEdgesWithSameSource(edges, animationState);

        const float animationSpeed = 0.01f; // Speed of animation

        for (const auto& edgePair : edgeData) {
            int edgeIndex = edgePair.first;
            const Edge& currentEdge = edges[edgeIndex];

            if (!animationState.isAnimating) return;

            if (animationState.progress == 0.0f) {
                animationState.startPos = glm::vec2(currentEdge.startX / 20.0f * expand, currentEdge.startY / 20.0f * expand);
                animationState.endPos = glm::vec2(currentEdge.endX / 20.0f * expand, currentEdge.endY / 20.0f * expand);
            }

            // Interpolate position between start and end
            glm::vec2 interpolatedPosition = animationState.startPos + animationState.progress * (animationState.endPos - animationState.startPos);

            // Update cube position
            float cubeX = interpolatedPosition.x;
            float cubeY = interpolatedPosition.y;

            // Draw cube at the new position
            drawCube(cubeX, cubeY); // Assuming there's a function to draw cube at a given position

            // Update animation progress
            animationState.progress += animationSpeed;
            if (animationState.progress >= 1.0f) {
                animationState.progress = 0.0f;

                int sourceID = currentEdge.source;
                std::vector<std::pair<int, std::string>> newEdgeData = findAllEdgesWithSameSource(edges, animationState);

                decreaseMarking(places, sourceID);

                for (const auto& newEdgePair : newEdgeData) {
                    int targetID = newEdgePair.first;
                    int multiplicity = std::stoi(newEdgePair.second);

                    // Execute some animation or processing for the targetID
                    // For example:
                    // increaseMarking(places, targetID, multiplicity);

                    std::cout << "Animating edge from sourceID: " << sourceID << " to targetID: " << targetID << " with multiplicity: " << multiplicity << std::endl;
                }

                std::cout << "Animation complete for current edge." << std::endl;
            }
        }
        typeofedge = 0;
    }
}