#include <iostream>
#include <vector>
#include <string>
#include <rapidxml.hpp>
#include <rapidxml_utils.hpp>
#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include "constants.h"
#include "lodepng.h"
#include "shaderprogram.h"
#include "myCube.h"
#include <glm/gtc/type_ptr.hpp>


using namespace rapidxml;




float speed_x = 0;
float speed_y = 0;
float aspectRatio = 1;

float camfr = 0;
float camlr = 0;
float s = 0;


ShaderProgram* sp;


struct Transition {
    float x, y;
    std::string type;
    std::string ID;
};


struct Edge {
    float startX, startY;
    float endX, endY;
    int source, target;
    std::string multiplicity;
};


struct Place {
    float x, y;
    std::string marking;
    std::string ID;
};

//Odkomentuj, ¿eby rysowaæ kostkê
float* cVertices = myCubeVertices;
float* cNormals = myCubeNormals;
float* cTexCoords = myCubeTexCoords;
float* cColors = myCubeColors;
int cVertexCount = myCubeVertexCount;






//Procedura obs³ugi b³êdów
void error_callback(int error, const char* description) {
	fputs(description, stderr);
}


void keyCallback(GLFWwindow* window, int key, int scancode, int action, int mods) {
	if (action == GLFW_PRESS) {
		if (key == GLFW_KEY_LEFT) speed_x = -PI / 2;
		if (key == GLFW_KEY_RIGHT) speed_x = PI / 2;
		if (key == GLFW_KEY_UP) speed_y = PI / 2;
		if (key == GLFW_KEY_DOWN) speed_y = -PI / 2;
	}
	if (action == GLFW_RELEASE) {
		if (key == GLFW_KEY_LEFT) speed_x = 0;
		if (key == GLFW_KEY_RIGHT) speed_x = 0;
		if (key == GLFW_KEY_UP) speed_y = 0;
		if (key == GLFW_KEY_DOWN) speed_y = 0;
	}

    if (action == GLFW_REPEAT || action == GLFW_PRESS) {
        if (key == GLFW_KEY_A) {
            camlr += 0.5f; // Increase camlr when 'A' key is held down
        }
        if (key == GLFW_KEY_D) {
            camlr -= 0.5f; // Decrease camlr when 'D' key is held down
        }
        if (key == GLFW_KEY_W) {
            camfr += 0.5f; // Increase camfr when 'W' key is held down
        }
        if (key == GLFW_KEY_S) {
            camfr -= 0.5f; // Decrease camfr when 'S' key is held down
        }
    }
}


void scroll_callback(GLFWwindow* window, double xoffset, double yoffset) {

    if (yoffset > 0) {
        s += 0.5;
    }
    if (yoffset < 0) {
        s -= 0.5;
    }

}


void windowResizeCallback(GLFWwindow* window, int width, int height) {
	if (height == 0) return;
	aspectRatio = (float)width / (float)height;
	glViewport(0, 0, width, height);
}

//Procedura inicjuj¹ca
void initOpenGLProgram(GLFWwindow* window) {
	//************Tutaj umieszczaj kod, który nale¿y wykonaæ raz, na pocz¹tku programu************
	glClearColor(0, 0, 0, 1);
	glEnable(GL_DEPTH_TEST);
	glfwSetWindowSizeCallback(window, windowResizeCallback);
	glfwSetKeyCallback(window, keyCallback);
    glfwSetScrollCallback(window, scroll_callback);

	sp = new ShaderProgram("v_simplest.glsl", NULL, "f_simplest.glsl");
}




//Zwolnienie zasobów zajêtych przez program
void freeOpenGLProgram(GLFWwindow* window) {
	//************Tutaj umieszczaj kod, który nale¿y wykonaæ po zakoñczeniu pêtli g³ównej************

	delete sp;
}




void drawPlaces(const std::vector<Place>& places) {
    for (const auto& node : places) {
        glm::mat4 M = glm::mat4(1.0f);
        M = glm::translate(M, glm::vec3(node.x / 20, node.y / 20, 0.0f)); //Wylicz macierz modelu

        glUniformMatrix4fv(sp->u("M"), 1, false, glm::value_ptr(M));

        glEnableVertexAttribArray(sp->a("vertex"));  //W³¹cz przesy³anie danych do atrybutu vertex
        glVertexAttribPointer(sp->a("vertex"), 4, GL_FLOAT, false, 0, cVertices); //Wska¿ tablicê z danymi dla atrybutu vertex



        //glEnableVertexAttribArray(sp->a("color"));
        //glVertexAttribPointer(sp->a("color"), 4, GL_FLOAT, false, 0, myCubeColors);

        glUniform4f(sp->u("color"), 1, 0, 0, 1);

        glDrawArrays(GL_TRIANGLES, 0, cVertexCount); //Narysuj obiekt

        glDisableVertexAttribArray(sp->a("vertex"));  //Wy³¹cz przesy³anie danych do atrybutu vertex
        glDisableVertexAttribArray(sp->a("color"));
    }

}

void drawTransitions(const std::vector<Transition>& transitions) {
    for (const auto& node : transitions) {
        glm::mat4 M = glm::mat4(1.0f);
        M = glm::translate(M, glm::vec3(node.x / 20, node.y / 20, 0.0f)); //Wylicz macierz modelu

        glUniformMatrix4fv(sp->u("M"), 1, false, glm::value_ptr(M));

        glEnableVertexAttribArray(sp->a("vertex"));  //W³¹cz przesy³anie danych do atrybutu vertex
        glVertexAttribPointer(sp->a("vertex"), 4, GL_FLOAT, false, 0, cVertices); //Wska¿ tablicê z danymi dla atrybutu vertex

        glUniform4f(sp->u("color"), 1, 1, 0, 1);


        //glEnableVertexAttribArray(sp->a("color"));
        //glVertexAttribPointer(sp->a("color"), 4, GL_FLOAT, false, 0, myCubeColors);


        glDrawArrays(GL_TRIANGLES, 0, cVertexCount); //Narysuj obiekt

        glDisableVertexAttribArray(sp->a("vertex"));  //Wy³¹cz przesy³anie danych do atrybutu vertex
        glDisableVertexAttribArray(sp->a("color"));
    }
}



//void drawEdges(const std::vector<Edge>& edges, const std::vector<Place>& places, const std::vector<Transition>& transitions) {
//    for (const auto& edge : edges) {
//        glm::vec3 startPoint, endPoint;
//
//        // Szukanie punktu pocz¹tkowego krawêdzi
//        for (const auto& place : places) {
//            if (place.ID == std::to_string(edge.source)) {
//                startPoint = glm::vec3(place.x / 20, place.y / 20, 0.0f);
//                break;
//            }
//        }
//        if (startPoint == glm::vec3(0.0f)) {
//            for (const auto& transition : transitions) {
//                if (transition.ID == std::to_string(edge.source)) {
//                    startPoint = glm::vec3(transition.x / 20, transition.y / 20, 0.0f);
//                    break;
//                }
//            }
//        }
//
//        // Szukanie punktu koñcowego krawêdzi
//        for (const auto& place : places) {
//            if (place.ID == std::to_string(edge.target)) {
//                endPoint = glm::vec3(place.x / 20, place.y / 20, 0.0f);
//                break;
//            }
//        }
//        if (endPoint == glm::vec3(0.0f)) {
//            for (const auto& transition : transitions) {
//                if (transition.ID == std::to_string(edge.target)) {
//                    endPoint = glm::vec3(transition.x / 20, transition.y / 20, 0.0f);
//                    break;
//                }
//            }
//        }
//        
//        // Rysowanie krawêdzi
//        glm::vec3 direction = endPoint + startPoint;
//        glm::vec3 scale = glm::vec3(glm::length(direction), 0.1f, 0.1f);
//        glm::vec3 center = direction / 2.0f;
//
//
//        glm::mat4 M = glm::mat4(1.0f);
//        M = glm::translate(M, center); // Wylicz macierz translacji
//        //M = glm::rotate(M, atan2(direction.y, direction.x), glm::vec3(0, 0, 1)); // Wylicz macierz rotacji
//        M = glm::scale(M, scale); // Wylicz macierz skalowania
//
//        glUniformMatrix4fv(sp->u("M"), 1, false, glm::value_ptr(M));
//
//        glEnableVertexAttribArray(sp->a("vertex"));  // W³¹cz przesy³anie danych do atrybutu vertex
//        glVertexAttribPointer(sp->a("vertex"), 4, GL_FLOAT, false, 0, cVertices); // Wska¿ tablicê z danymi dla atrybutu vertex
//
//        glEnableVertexAttribArray(sp->a("color"));
//        glVertexAttribPointer(sp->a("color"), 4, GL_FLOAT, false, 0, myCubeColors);
//
//        glDrawArrays(GL_TRIANGLES, 0, cVertexCount); // Narysuj obiekt
//
//        glDisableVertexAttribArray(sp->a("vertex"));  // Wy³¹cz przesy³anie danych do atrybutu vertex
//    }
//}


void drawEdges(const std::vector<Edge>& edges, const std::vector<Place>& places, const std::vector<Transition>& transitions) {
    for (const auto& edge : edges) {
        float startX, startY, endX, endY;

        // Szukanie punktu pocz¹tkowego krawêdzi
        for (const auto& place : places) {
            if (place.ID == std::to_string(edge.source)) {
                startX = place.x / 20.0f;
                startY = place.y / 20.0f;
                break;
            }
        }
       
            for (const auto& transition : transitions) {
                if (transition.ID == std::to_string(edge.source)) {
                    startX = transition.x / 20.0f;
                    startY = transition.y / 20.0f;
                    break;
                }
            }
        

        // Szukanie punktu koñcowego krawêdzi
        for (const auto& place : places) {
            if (place.ID == std::to_string(edge.target)) {
                endX = place.x / 20.0f;
                endY = place.y / 20.0f;
                break;
            }
        }
        
            for (const auto& transition : transitions) {
                if (transition.ID == std::to_string(edge.target)) {
                    endX = transition.x / 20.0f;
                    endY = transition.y / 20.0f;
                    break;
                }
            }
        

        // Obliczanie d³ugoœci i kierunku prostopad³oœcianu
        float length = glm::distance(glm::vec2(startX, startY)/2.0f, glm::vec2(endX, endY)/2.0f);
        glm::vec2 direction = glm::normalize(glm::vec2(endX - startX, endY - startY));

        // Ustawienie skali prostopad³oœcianu (d³ugoœæ, szerokoœæ, wysokoœæ)
        glm::vec3 scale = glm::vec3(length, 0.1f, 0.1f);

        // Obliczanie œrodka prostopad³oœcianu
        glm::vec3 center = glm::vec3((startX + endX) / 2.0f, (startY + endY) / 2.0f, 0.0f);

        // Obliczanie k¹ta obrotu prostopad³oœcianu (na p³aszczyŸnie XY)
        float angle = atan2(direction.y, direction.x);

        // Rysowanie prostopad³oœcianu
        glm::mat4 M = glm::mat4(1.0f);
        M = glm::translate(M, center); // Wylicz macierz translacji
        M = glm::rotate(M, angle, glm::vec3(0, 0, 1)); // Wylicz macierz rotacji
        M = glm::scale(M, scale); // Wylicz macierz skalowania

        glUniformMatrix4fv(sp->u("M"), 1, false, glm::value_ptr(M));

        glEnableVertexAttribArray(sp->a("vertex"));  // W³¹cz przesy³anie danych do atrybutu vertex
        glVertexAttribPointer(sp->a("vertex"), 4, GL_FLOAT, false, 0, cVertices); // Wska¿ tablicê z danymi dla atrybutu vertex

        //glEnableVertexAttribArray(sp->a("color"));
        //glVertexAttribPointer(sp->a("color"), 4, GL_FLOAT, false, 0, myCubeColors);

        glUniform4f(sp->u("color"), 0, 0, 1, 1);

        glDrawArrays(GL_TRIANGLES, 0, cVertexCount); // Narysuj obiekt

        glDisableVertexAttribArray(sp->a("vertex"));  // Wy³¹cz przesy³anie danych do atrybutu vertex
    }
}


void drawScene(GLFWwindow* window, float angle_x, float angle_y, const std::vector<Place>& places, const std::vector<Transition>& transitions, const std::vector<Edge>& edges) {
    //************Tutaj umieszczaj kod rysuj¹cy obraz******************l
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glm::mat4 V = glm::lookAt(glm::vec3(camlr + 0.0f, 0.0f, camfr + (-5.0f)),
        glm::vec3(camlr - 0.0f, 0.0f, camfr - 0.0f),
        glm::vec3(0.0f, 1.0f, 0.0f));

    glm::mat4 P = glm::perspective(50.0f * PI / 180.0f, aspectRatio, 0.01f, 50.0f); //Wylicz macierz rzutowania

    sp->use(); //Aktywacja programu cieniuj¹cego
    //Przeslij parametry programu cieniuj¹cego do karty graficznej
    glUniformMatrix4fv(sp->u("P"), 1, false, glm::value_ptr(P));
    glUniformMatrix4fv(sp->u("V"), 1, false, glm::value_ptr(V));
    






    drawPlaces(places);
    drawTransitions(transitions);
    drawEdges(edges, places, transitions);


    glfwSwapBuffers(window); //Przerzuæ tylny bufor na przedni
}

int main(void) {

    std::vector<Place> places;
    std::vector<Transition> transitions;
    std::vector<Edge> edges;
    


    xml_document<> doc;
    file<> xmlFile("test.pn");
    doc.parse<0>(xmlFile.data());

    xml_node<>* root = doc.first_node();

    // place
    xml_node<>* placeClassNode = root->first_node("nodeclasses")->first_node("nodeclass");
    for (xml_node<>* placeNode = placeClassNode->first_node("node");
        placeNode;
        placeNode = placeNode->next_sibling("node")) {

        float x = std::stof(placeNode->first_node("graphics")->first_node("graphic")->first_attribute("x")->value());
        float y = std::stof(placeNode->first_node("graphics")->first_node("graphic")->first_attribute("y")->value());
        std::string ID = placeNode->first_attribute("id")->value();
        //places.push_back({ x, y, "Place", ID });

        xml_node<>* markingNode = nullptr;
        for (xml_node<>* attributeNode = placeNode->first_node("attribute"); attributeNode; attributeNode = attributeNode->next_sibling("attribute")) {
            if (std::string(attributeNode->first_attribute("name")->value()) == "Marking") {
                markingNode = attributeNode;
                break;
            }
        }


        if (markingNode) {

            std::string marking = markingNode->first_node()->value();
            places.push_back({ x, y, marking, ID });
        }
    }

    // transition
    xml_node<>* transitionClassNode = placeClassNode->next_sibling("nodeclass");
    for (xml_node<>* transitionNode = transitionClassNode->first_node("node");
        transitionNode;
        transitionNode = transitionNode->next_sibling("node")) {
        float x = std::stof(transitionNode->first_node("graphics")->first_node("graphic")->first_attribute("x")->value());
        float y = std::stof(transitionNode->first_node("graphics")->first_node("graphic")->first_attribute("y")->value());
        std::string ID = transitionNode->first_attribute("id")->value();
        transitions.push_back({ x, y, "Transition", ID });
    }

    // krawêdŸ
    xml_node<>* edgeClassNode = root->first_node("edgeclasses")->first_node("edgeclass");
    for (xml_node<>* edgeNode = edgeClassNode->first_node("edge");
        edgeNode;
        edgeNode = edgeNode->next_sibling("edge")) {
        float startX = std::stof(edgeNode->first_node("graphics")->first_node("graphic")->first_node("points")->first_node("point")->first_attribute("x")->value());
        float startY = std::stof(edgeNode->first_node("graphics")->first_node("graphic")->first_node("points")->first_node("point")->first_attribute("y")->value());
        float endX = std::stof(edgeNode->first_node("graphics")->first_node("graphic")->first_node("points")->last_node("point")->first_attribute("x")->value());
        float endY = std::stof(edgeNode->first_node("graphics")->first_node("graphic")->first_node("points")->last_node("point")->first_attribute("y")->value());
        int source = std::stof(edgeNode->first_attribute("source")->value());
        int target = std::stof(edgeNode->first_attribute("target")->value());


        xml_node<>* multiplicityNode = nullptr;
        for (xml_node<>* attributeNode = edgeNode->first_node("attribute"); attributeNode; attributeNode = attributeNode->next_sibling("attribute")) {
            if (std::string(attributeNode->first_attribute("name")->value()) == "Multiplicity") {
                multiplicityNode = attributeNode;
                break;
            }
        }


        if (multiplicityNode) {

            std::string multiplicity = multiplicityNode->first_node()->value();
            //markedPlaces.push_back({ x, y, marking, ID });
            edges.push_back({ startX, startY, endX, endY, source, target, multiplicity });
        }



    }


    GLFWwindow* window; //WskaŸnik na obiekt reprezentuj¹cy okno

    glfwSetErrorCallback(error_callback); //Zarejestruj procedurê obs³ugi b³êdów

    if (!glfwInit()) { //Zainicjuj bibliotekê GLFW
        fprintf(stderr, "Nie mo¿na zainicjowaæ GLFW.\n");
        exit(EXIT_FAILURE);
    }

    window = glfwCreateWindow(800, 600, "OpenGL", NULL, NULL);  //Utwórz okno 800x600 o tytule "OpenGL" i kontekst OpenGL.

    if (!window) //Je¿eli okna nie uda³o siê utworzyæ, to zamknij program
    {
        fprintf(stderr, "Nie mo¿na utworzyæ okna.\n");
        glfwTerminate();
        exit(EXIT_FAILURE);
    }

    glfwMakeContextCurrent(window); //Od tego momentu kontekst okna staje siê aktywny i polecenia OpenGL bêd¹ dotyczyæ w³aœnie jego.
    glfwSwapInterval(1); //Czekaj na 1 powrót plamki przed pokazaniem ukrytego bufora

    if (glewInit() != GLEW_OK) { //Zainicjuj bibliotekê GLEW
        fprintf(stderr, "Nie mo¿na zainicjowaæ GLEW.\n");
        exit(EXIT_FAILURE);
    }

    initOpenGLProgram(window); //Operacje inicjuj¹ce

    //G³ówna pêtla
    float angle_x = 0; //Aktualny k¹t obrotu obiektu
    float angle_y = 0; //Aktualny k¹t obrotu obiektu
    glfwSetTime(0); //Zeruj timer

    

    while (!glfwWindowShouldClose(window)) //Tak d³ugo jak okno nie powinno zostaæ zamkniête
    {
        angle_x += speed_x * glfwGetTime(); //Zwiêksz/zmniejsz k¹t obrotu na podstawie prêdkoœci i czasu jaki up³yna³ od poprzedniej klatki
        angle_y += speed_y * glfwGetTime(); //Zwiêksz/zmniejsz k¹t obrotu na podstawie prêdkoœci i czasu jaki up³yna³ od poprzedniej klatki
        glfwSetTime(0); //Zeruj timer
        drawScene(window, angle_x, angle_y, places, transitions, edges); //Wykonaj procedurê rysuj¹c¹
        glfwPollEvents(); //Wykonaj procedury callback w zale¿noœci od zdarzeñ jakie zasz³y.
    }

    freeOpenGLProgram(window);

    glfwDestroyWindow(window); //Usuñ kontekst OpenGL i okno
    glfwTerminate(); //Zwolnij zasoby zajête przez GLFW
    exit(EXIT_SUCCESS);
}







